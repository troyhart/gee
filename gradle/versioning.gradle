class ProjectVersion
{
  java.text.SimpleDateFormat timestampFormat = new java.text.SimpleDateFormat('yyyyMMddHHmmssZ')
  //timestampFormat.timeZone = TimeZone.getTimeZone("UTC")

  Integer major
  Integer minor
  String itr
  Boolean release
  Date buildTime
  String buildTimestamp

  ProjectVersion(Project project, Integer major, Integer minor) {
    initBuildTime(project)
    this.major = major
    this.minor = minor
    this.release = Boolean.FALSE
    this.itr = buildTimestamp
  }

  ProjectVersion(Project project, Integer major, Integer minor, Boolean release) {
    this(project, major,minor)
    this.release = release
  }

  ProjectVersion(Project project, Integer major, Integer minor, String releaseCandidate) {
    this(project, major,minor)
    this.release = Boolean.FALSE
    this.itr = releaseCandidate
  }

  private void initBuildTime(Project project) {

    if (project.hasProperty("buildTimestamp")) {
      buildTime = timestampFormat.parse(project.buildTimestamp)
      buildTimestamp = project.buildTimestamp
    } else {
      File timestampFile = project.file("$project.buildDir/timestamp.txt")
      if (timestampFile.isFile()) {
        boolean uptodate = true
        def modified = timestampFile.lastModified()
        // If any of the main source has changed, then
        // the timestamp is not up to date
        project.fileTree('src/main').visit {fte ->
          if (fte.file.isFile() && fte.lastModified > modified) {
            uptodate = false
            fte.stopVisiting()
          }
        }
        if (!uptodate) {
          timestampFile.setLastModified(new Date().time)
        }
      } else {
        timestampFile.parentFile.mkdirs()
        timestampFile.createNewFile()
      }

      buildTime = new Date(timestampFile.lastModified())
      buildTimestamp = timestampFormat.format(buildTime)
    }
  }

  @Override
  String toString() {
    "$major.$minor${release ? '' : "-$itr"}"
  }
}

class ReleaseVersionTask extends DefaultTask 
{
  @Input Boolean release
  @OutputFile File destFile
  
  ReleaseVersionTask() 
  {
    group = 'versioning'
    description = 'Makes project a release version.'
  }
  
  @TaskAction
  void start() 
  {
    project.version.release = Boolean.TRUE
    ant.propertyfile(file: destFile) {
      entry(key:'release', type: 'string', operation: '=', value: 'true')
    }
  }
}

// Add dynamic tasks for incrementing the major and minor version of 
// the project. The change is persisted in the versionPropsFile.
// 
tasks.addRule("Pattern: increment<Classifier>Version -- Increments the project version classifier.") { String taskName ->
  if (taskName.startsWith('increment') && taskName.endsWith('Version')) {
    task(taskName) << {
      String classifier = (taskName - 'increment' - 'Version').toLowerCase()
      String currentVersion = version.toString()
      
      switch(classifier) {
        case 'major': ++version.major
                      break
        case 'minor': ++version.minor
                      break
        default: throw new GradleException("Invalid version type '$classifier'. Allowed types: ['Major', 'Minor']")
      }
      
      String newVersion = version.toString()
      logger.info "Incrementing $classifier project version: $currentVersion -> $newVersion"
      
      ant.propertyfile(file: versionPropsFile) {
        entry(key: classifier, type: 'int', operation: '+', value: 1)
      }
    }
  }
}

// Reference to the project specific version information properties files.
ext.versionPropsFile = file("version.properties")

// a method that returns a new instance of a ProjectVersion object that
// has been initialized with the project specific version information.
ProjectVersion readVersion()  
{
  logger.quiet "Reading $versionPropsFile.canonicalPath"
  
  if (!versionPropsFile.exists()) {
    throw new GradleException("missing required version.properties: $versionPropsFile.canonicalPath")
  }
  
  Properties versionProps = new Properties()
  
  versionPropsFile.withInputStream { stream ->
    versionProps.load(stream)
  }
  
  new ProjectVersion(project, versionProps.major.toInteger(), versionProps.minor.toInteger(), versionProps.release.toBoolean())
}

// A configuration task that set's the project's version to the result of readVersion()
task loadVersion(group: 'versioning', description: 'A configuration task that automatically reads the project specific version.properties file and initializes the project\'s version.') {
  project.version = readVersion()
}

// set the version's release flag to TRUE, persisting this value in the versionPropsFile
task makeReleaseVersion(type: ReleaseVersionTask) {
  release = version.release
  destFile = versionPropsFile
}

task printVersion(group: 'versioning', description: 'Prints version information.') << {
  if (version.release) {
    logger.quiet "Build Time: $version.buildTimestamp"
  }
  logger.quiet "Version: $version"
}

// create a distribution
task createDistribution(type: Zip, dependsOn: makeReleaseVersion) {
  // Infers dependency on war task by reference to the output of the War task.
  from war.outputs.files
  
  // pull all source files into src directory of zip file.
  from(sourceSets*.allSource) {
    into 'src'
  }
  
  // add version file to zip.
  from(rootDir) {
    include versionPropsFile.name
  }
}

task backupReleaseDistribution(type: Copy) {
  // Infers dependency on createDistribution task by reference to it's outpu
  from createDistribution.outputs.files
  into "$buildDir/backup"
}

task release(dependsOn: backupReleaseDistribution) << {
  logger.quiet 'Releasing project...'
}
