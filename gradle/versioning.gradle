import java.text.SimpleDateFormat
import java.util.TimeZone

import org.gradle.api.GradleException
import org.gradle.api.execution.TaskExecutionGraph
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.bundling.Zip
import org.slf4j.Logger
import org.slf4j.LoggerFactory

class ProjectVersion
{
  static SimpleDateFormat timestampFormat = new SimpleDateFormat('yyyyMMddHHmmssZ')
  static {
    timestampFormat.timeZone = TimeZone.getTimeZone("UTC")
  }
  
  File propertiesFile
  File timestampFile
  
  // version.properties attributes
  private Integer major
  private Integer minor
  private Integer patch
  // timestamp.txt lastModified attribute
  Date buildTime
  
  boolean release
  String buildLabel

  ProjectVersion(Project project) {
    propertiesFile = project.file("version.properties")
    if (!propertiesFile.exists()) {
      throw new GradleException("missing required version.properties: $propertiesFile.canonicalPath")
    }
    Properties versionProps = new Properties()
    propertiesFile.withInputStream { stream ->
      versionProps.load(stream)
    }
    
    this.major = versionProps.major.toInteger()
    this.minor = versionProps.minor.toInteger()
    this.patch = versionProps.patch.toInteger()

    timestampFile = project.file("build-timestamp.txt")
    if (timestampFile.isFile()) {
      boolean uptodate = true
      Date modified = new Date(timestampFile.lastModified())
      // If any of the main source has changed, then
      // the timestamp is not up to date
      project.fileTree('src/main').visit { fte ->
        if (fte.file.isFile() && fte.lastModified > modified.time) {
          uptodate = false
          fte.stopVisiting()
        }
      }
      if (!uptodate) {
        // update the last modified date on the timestamp file
        timestampFile.setLastModified(new Date().time)
      }
    } else {
      timestampFile.parentFile.mkdirs()
      timestampFile.createNewFile()
    }
    
    this.release = project.hasProperty('release') ? project.release : false
    
    this.buildTime = new Date(timestampFile.lastModified())
    if (project.hasProperty('releaseCandidate')) {
      this.buildLabel = project.releaseCandidate
    } else {
      this.buildLabel = "SNAPSHOT-${timestampFormat.format(buildTime)}"
    }
  }
  
  @Override
  String toString() {
    "$major.$minor.$patch${release ? '' : "-$buildLabel"}"
  }
}

// Add dynamic tasks for incrementing the major and minor version of 
// the project. The change is persisted in version.propertiesFile.
// 
tasks.addRule("Pattern: increment<Classifier>Version -- Increments the project version classifier.") { String taskName ->
  if (taskName.startsWith('increment') && taskName.endsWith('Version')) {
    task(taskName) << {
      String classifier = (taskName - 'increment' - 'Version').toLowerCase()
      String currentVersion = project.version.toString()
      
      switch(classifier) {
        case 'major': ++project.version.major
                      break
        case 'minor': ++project.version.minor
                      break
        case 'patch': ++project.version.patch
                      break
        default: throw new GradleException("Invalid version type '$classifier'. Allowed types: ['Major', 'Minor']")
      }
      
      String newVersion = project.version.toString()
      logger.info "Incrementing $classifier project version: $currentVersion -> $newVersion"
      
      ant.propertyfile(file: project.version.propertiesFile) {
        entry(key: classifier, type: 'int', operation: '+', value: 1)
      }
    }
  }
}

// A configuration task that set's the project's version to the result of readVersion()
task loadVersion(group: 'versioning', description: 'An automatic configuraiton task; no need to execute this one.') {
  project.version = new ProjectVersion(project)
}

// Perhaps there is no place in our build system for a distribution creation
// task such as this one. I need to get clear on the role of the CD build
// server, in its interactions with the build script.
//
task sourceDistribution(type: Zip) {
  // Infers dependency on jar task by reference to its output.
  from jar.outputs.files
  
  // pull all source files into src directory of zip file.
  from(sourceSets*.allSource) {
    into 'src'
  }
  
  // add version file to zip.
  from(rootDir) {
    include project.version.propertiesFile.name
  }
}

void listDirectory(Integer level, File directory) { 
  def files = directory.listFiles()
  for (int f=0; f<files.size(); f++) {
    for (int i=0; i<level; i++) {
      print '    '
    }
    if (f < files.size()-1) {
      print '├── '
    } else {
      print '└── '
    }
    print files[f].name
    println files[f].directory ? " [D --> count: ${files[f].listFiles().size()}; modified: ${new Date(files[f].lastModified())}]" : " [F --> size: ${files[f].size()}; modified: ${new Date(files[f].lastModified())}]"
    if (files[f].directory) {
      listDirectory(level+1, files[f])
    }
  }
}

task printVersion(dependsOn: 'build', group: 'versioning', description: 'Prints version information.') << {
  if (project.version.release) {
    logger.quiet "Build Time: $project.version.buildTime"
  }
  logger.quiet "Version: $version"
}

task showBuildArtifacts(dependsOn: 'printVersion', group: 'versioning', description: 'Depends on \'build\' and then lists the build directory.') << {
  println "$project.version.timestampFile.name --> ${new Date(project.version.timestampFile.lastModified())}"
  println "$buildDir.name [D --> count: ${buildDir.listFiles().size()}; modified: ${new Date(buildDir.lastModified())}]"
  listDirectory(0,buildDir)
}
